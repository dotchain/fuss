// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.
//
// Code generated by . DO NOT EDIT.

package datum

import (
	streams "github.com/dotchain/dot/streams"
)

// NewAvg is the constructor for AvgFunc
func NewAvg() (update AvgFunc, closeAll func()) {
	var refresh func()

	var lasta Array
	var lastresult float32
	var initialized bool
	countFnMap := map[interface{}]CountFunc{}
	countCloseMap := map[interface{}]func(){}
	countUsedMap := map[interface{}]bool{}

	sumFnMap := map[interface{}]SumFunc{}
	sumCloseMap := map[interface{}]func(){}
	sumUsedMap := map[interface{}]bool{}

	depsLocal := &sumDeps{
		count: func(key interface{}, a Array) (result int) {
			countUsedMap[key] = true
			if countFnMap[key] == nil {
				countFnMap[key], countCloseMap[key] = NewCount()
			}
			return countFnMap[key](key, a)
		},

		sum: func(key interface{}, a Array) (result int) {
			sumUsedMap[key] = true
			if sumFnMap[key] == nil {
				sumFnMap[key], sumCloseMap[key] = NewSum()
			}
			return sumFnMap[key](key, a)
		},
	}

	close := func() {
		for key := range countCloseMap {
			if !countUsedMap[key] {
				countCloseMap[key]()
				delete(countCloseMap, key)
				delete(countFnMap, key)
			}
		}
		countUsedMap = map[interface{}]bool{}

		for key := range sumCloseMap {
			if !sumUsedMap[key] {
				sumCloseMap[key]()
				delete(sumCloseMap, key)
				delete(sumFnMap, key)
			}
		}
		sumUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(deps interface{}, a Array) (result float32) {
		refresh = func() {

			lastresult = avg(depsLocal, a)

			close()
		}

		if initialized {
			switch {
			case lasta.Equals(a):

			default:

				return lastresult
			}
		}
		initialized = true
		lasta = a
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewCloser is the constructor for CloserFunc
func NewCloser() (update CloserFunc, closeAll func()) {
	var refresh func()

	var lastcloserState closable
	var lastresult int
	var initialized bool

	depsLocal := &none{}

	close := func() {}

	closeAll = func() {
		close()
		lastcloserState.Close()

	}

	update = func(deps interface{}) (result int) {
		refresh = func() {

			lastcloserState, lastresult = closer(depsLocal, lastcloserState)

			close()
		}

		if initialized {
			switch {

			default:

				return lastresult
			}
		}
		initialized = true

		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewCount is the constructor for CountFunc
func NewCount() (update CountFunc, closeAll func()) {
	var refresh func()

	var lasta Array
	var lastresult int
	var initialized bool

	depsLocal := &none{}

	close := func() {}

	closeAll = func() {
		close()

	}

	update = func(deps interface{}, a Array) (result int) {
		refresh = func() {

			lastresult = count(depsLocal, a)

			close()
		}

		if initialized {
			switch {
			case lasta.Equals(a):

			default:

				return lastresult
			}
		}
		initialized = true
		lasta = a
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewEdgeTrigger is the constructor for EdgeTriggerFunc
func NewEdgeTrigger() (update EdgeTriggerFunc, closeAll func()) {
	var refresh func()

	var laststate *streams.Bool
	var lastinput int
	var lastr1 int
	var lastr2 int
	var initialized bool

	depsLocal := &none{}

	close := func() {}

	closeAll = func() {
		close()

		if laststate != nil {
			laststate.Stream.Nextf(&initialized, nil)
		}
	}

	update = func(deps interface{}, input int) (r1 int, r2 int) {
		refresh = func() {

			if laststate != nil {
				laststate = laststate.Latest()
				laststate.Stream.Nextf(&initialized, nil)
			}
			laststate, lastr1, lastr2 = edgeTrigger(depsLocal, laststate, input)

			if laststate != nil {
				laststate = laststate.Latest()
				laststate.Stream.Nextf(&initialized, refresh)
			}
			close()
		}

		if initialized {
			switch {

			case lastinput != input:
			default:

				return lastr1, lastr2
			}
		}
		initialized = true
		lastinput = input
		refresh()
		return lastr1, lastr2
	}

	return update, closeAll
}

// NewSum is the constructor for SumFunc
func NewSum() (update SumFunc, closeAll func()) {
	var refresh func()

	var lasta Array
	var lastresult int
	var initialized bool

	depsLocal := &none{}

	close := func() {}

	closeAll = func() {
		close()

	}

	update = func(deps interface{}, a Array) (result int) {
		refresh = func() {

			lastresult = sum(depsLocal, a)

			close()
		}

		if initialized {
			switch {
			case lasta.Equals(a):

			default:

				return lastresult
			}
		}
		initialized = true
		lasta = a
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewVariadic is the constructor for VariadicFunc
func NewVariadic() (update VariadicFunc, closeAll func()) {
	var refresh func()

	var lastargs []int
	var lastresult int
	var initialized bool

	depsLocal := &none{}

	close := func() {}

	closeAll = func() {
		close()

	}

	update = func(deps interface{}, args ...int) (result int) {
		refresh = func() {

			lastresult = variadic(depsLocal, args...)

			close()
		}

		if initialized {
			switch {

			default:

				if len(lastargs) != len(args) {
					break
				}
				diff := false
				for kk := 0; !diff && kk < len(args); kk++ {

					diff = lastargs[kk] != args[kk]

				}
				if diff {
					break
				}

				return lastresult
			}
		}
		initialized = true
		lastargs = args
		refresh()
		return lastresult
	}

	return update, closeAll
}
