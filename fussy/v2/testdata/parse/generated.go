// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.
//
// Code generated by . DO NOT EDIT.

package datum

// NewAvg is the constructor for AvgFunc
func NewAvg() (update AvgFunc, close func()) {
	var lasta Array
	var lastresult1 float32
	var initialized bool
	countFnMap := map[interface{}]CountFunc{}
	countCloseMap := map[interface{}]func(){}
	countUsedMap := map[interface{}]bool{}

	sumFnMap := map[interface{}]SumFunc{}
	sumCloseMap := map[interface{}]func(){}
	sumUsedMap := map[interface{}]bool{}

	depsLocal := &sumDeps{
		count: func(key interface{}, a Array) (result1 int) {
			countUsedMap[key] = true
			if countFnMap[key] == nil {
				countFnMap[key], countCloseMap[key] = NewCount()
			}
			return countFnMap[key](key, a)
		},

		sum: func(key interface{}, a Array) (result1 int) {
			sumUsedMap[key] = true
			if sumFnMap[key] == nil {
				sumFnMap[key], sumCloseMap[key] = NewSum()
			}
			return sumFnMap[key](key, a)
		},
	}

	close = func() {
		for key := range countCloseMap {
			if !countUsedMap[key] {
				countCloseMap[key]()
				delete(countCloseMap, key)
				delete(countFnMap, key)
			}
		}
		countUsedMap = map[interface{}]bool{}

		for key := range sumCloseMap {
			if !sumUsedMap[key] {
				sumCloseMap[key]()
				delete(sumCloseMap, key)
				delete(sumFnMap, key)
			}
		}
		sumUsedMap = map[interface{}]bool{}
	}

	update = func(deps interface{}, a Array) (result1 float32) {
		if initialized {
			switch {
			case !equal(lasta, a):
			default:
				return lastresult1
			}
		}
		initialized = true
		lasta = a
		lastresult1 = avg(depsLocal, a)
		close()
		return lastresult1
	}

	return update, close
}

// NewCount is the constructor for CountFunc
func NewCount() (update CountFunc, close func()) {
	var lasta Array
	var lastresult1 int
	var initialized bool

	depsLocal := &none{}

	close = func() {}

	update = func(deps interface{}, a Array) (result1 int) {
		if initialized {
			switch {
			case !equal(lasta, a):
			default:
				return lastresult1
			}
		}
		initialized = true
		lasta = a
		lastresult1 = count(depsLocal, a)
		close()
		return lastresult1
	}

	return update, close
}

// NewEdgeTrigger is the constructor for EdgeTriggerFunc
func NewEdgeTrigger() (update EdgeTriggerFunc, close func()) {
	var laststate int
	var lastinput int
	var lastr1 int
	var lastr2 int
	var initialized bool

	depsLocal := &none{}

	close = func() {}

	update = func(deps interface{}, input int) (r1 int, r2 int) {
		if initialized {
			switch {
			case !equal(lastinput, input):
			default:
				return lastr1, lastr2
			}
		}
		initialized = true
		lastinput = input
		laststate, lastr1, lastr2 = edgeTrigger(depsLocal, laststate, input)
		close()
		return lastr1, lastr2
	}

	return update, close
}

// NewSum is the constructor for SumFunc
func NewSum() (update SumFunc, close func()) {
	var lasta Array
	var lastresult1 int
	var initialized bool

	depsLocal := &none{}

	close = func() {}

	update = func(deps interface{}, a Array) (result1 int) {
		if initialized {
			switch {
			case !equal(lasta, a):
			default:
				return lastresult1
			}
		}
		initialized = true
		lasta = a
		lastresult1 = sum(depsLocal, a)
		close()
		return lastresult1
	}

	return update, close
}
func equal(before, after interface{}) bool {
	if b, ok := before.(equals); ok {
		return b.Equals(after)
	}
	if a, ok := after.(equals); ok {
		return a.Equals(before)
	}
	return after == before
}

type equals interface {
	Equals(o interface{}) bool
}
