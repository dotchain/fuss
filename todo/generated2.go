// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.
//
// Code generated by . DO NOT EDIT.

package todo

import (
	streams "github.com/dotchain/dot/streams"
	dom "github.com/dotchain/fuss/dom"
	"github.com/dotchain/fuss/todo/controls"
)

// NewApp is the constructor for AppFunc
func NewApp() (update AppFunc, closeAll func()) {
	var refresh func()

	var laststate *TodoListStream
	var lastresult dom.Element
	var initialized bool
	collabFnMap := map[interface{}]CollabFunc{}
	collabCloseMap := map[interface{}]func(){}
	collabUsedMap := map[interface{}]bool{}

	depsLocal := &appDeps{
		collab: func(key interface{}, todos *TodoListStream) (result dom.Element) {
			collabUsedMap[key] = true
			if collabFnMap[key] == nil {
				collabFnMap[key], collabCloseMap[key] = NewCollab()
			}
			return collabFnMap[key](key, todos)
		},
	}

	close := func() {
		for key := range collabCloseMap {
			if !collabUsedMap[key] {
				collabCloseMap[key]()
				delete(collabCloseMap, key)
				delete(collabFnMap, key)
			}
		}
		collabUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(deps interface{}) (result dom.Element) {
		refresh = func() {

			if laststate != nil {
				laststate = laststate.Latest()
				laststate.Stream.Nextf(&initialized, nil)
			}
			laststate, lastresult = app(depsLocal, laststate)

			if laststate != nil {
				laststate = laststate.Latest()
				laststate.Stream.Nextf(&initialized, refresh)
			}
			close()
		}

		if initialized {
			switch {

			default:

				return lastresult
			}
		}
		initialized = true

		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewCollab is the constructor for CollabFunc
func NewCollab() (update CollabFunc, closeAll func()) {
	var refresh func()

	var lasttodos *TodoListStream
	var lastresult dom.Element
	var initialized bool
	textViewFnMap := map[interface{}]dom.TextViewFunc{}
	textViewCloseMap := map[interface{}]func(){}
	textViewUsedMap := map[interface{}]bool{}

	listViewFnMap := map[interface{}]ListViewFunc{}
	listViewCloseMap := map[interface{}]func(){}
	listViewUsedMap := map[interface{}]bool{}

	aFnMap := map[interface{}]dom.AFunc{}
	aCloseMap := map[interface{}]func(){}
	aUsedMap := map[interface{}]bool{}

	chromeFnMap := map[interface{}]controls.ChromeFunc{}
	chromeCloseMap := map[interface{}]func(){}
	chromeUsedMap := map[interface{}]bool{}

	depsLocal := &collabDeps{
		textView: func(key interface{}, styles dom.Styles, text string) (result dom.Element) {
			textViewUsedMap[key] = true
			if textViewFnMap[key] == nil {
				textViewFnMap[key], textViewCloseMap[key] = dom.NewTextView()
			}
			return textViewFnMap[key](key, styles, text)
		},

		listView: func(key interface{}, todos *TodoListStream) (result dom.Element) {
			listViewUsedMap[key] = true
			if listViewFnMap[key] == nil {
				listViewFnMap[key], listViewCloseMap[key] = NewListView()
			}
			return listViewFnMap[key](key, todos)
		},

		a: func(key interface{}, styles dom.Styles, href string, children ...dom.Element) (result dom.Element) {
			aUsedMap[key] = true
			if aFnMap[key] == nil {
				aFnMap[key], aCloseMap[key] = dom.NewA()
			}
			return aFnMap[key](key, styles, href, children...)
		},

		chrome: func(key interface{}, header dom.Element, body dom.Element, footer dom.Element) (result dom.Element) {
			chromeUsedMap[key] = true
			if chromeFnMap[key] == nil {
				chromeFnMap[key], chromeCloseMap[key] = controls.NewChrome()
			}
			return chromeFnMap[key](key, header, body, footer)
		},
	}

	close := func() {
		for key := range textViewCloseMap {
			if !textViewUsedMap[key] {
				textViewCloseMap[key]()
				delete(textViewCloseMap, key)
				delete(textViewFnMap, key)
			}
		}
		textViewUsedMap = map[interface{}]bool{}

		for key := range listViewCloseMap {
			if !listViewUsedMap[key] {
				listViewCloseMap[key]()
				delete(listViewCloseMap, key)
				delete(listViewFnMap, key)
			}
		}
		listViewUsedMap = map[interface{}]bool{}

		for key := range aCloseMap {
			if !aUsedMap[key] {
				aCloseMap[key]()
				delete(aCloseMap, key)
				delete(aFnMap, key)
			}
		}
		aUsedMap = map[interface{}]bool{}

		for key := range chromeCloseMap {
			if !chromeUsedMap[key] {
				chromeCloseMap[key]()
				delete(chromeCloseMap, key)
				delete(chromeFnMap, key)
			}
		}
		chromeUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(deps interface{}, todos *TodoListStream) (result dom.Element) {
		refresh = func() {

			lastresult = collab(depsLocal, todos)

			close()
		}

		if initialized {
			switch {

			case lasttodos != todos:
			default:

				return lastresult
			}
		}
		initialized = true
		lasttodos = todos
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewFilteredList is the constructor for FilteredListFunc
func NewFilteredList() (update FilteredListFunc, closeAll func()) {
	var refresh func()

	var lastfilter *streams.S16
	var lasttodos *TodoListStream
	var lastresult dom.Element
	var initialized bool
	vRunFnMap := map[interface{}]dom.VRunFunc{}
	vRunCloseMap := map[interface{}]func(){}
	vRunUsedMap := map[interface{}]bool{}

	todoFnMap := map[interface{}]TodoFunc{}
	todoCloseMap := map[interface{}]func(){}
	todoUsedMap := map[interface{}]bool{}

	depsLocal := &filteredListDeps{
		vRun: func(key interface{}, styles dom.Styles, cells ...dom.Element) (result dom.Element) {
			vRunUsedMap[key] = true
			if vRunFnMap[key] == nil {
				vRunFnMap[key], vRunCloseMap[key] = dom.NewVRun()
			}
			return vRunFnMap[key](key, styles, cells...)
		},

		todo: func(key interface{}, todoStream *TodoStream) (result dom.Element) {
			todoUsedMap[key] = true
			if todoFnMap[key] == nil {
				todoFnMap[key], todoCloseMap[key] = NewTodo()
			}
			return todoFnMap[key](key, todoStream)
		},
	}

	close := func() {
		for key := range vRunCloseMap {
			if !vRunUsedMap[key] {
				vRunCloseMap[key]()
				delete(vRunCloseMap, key)
				delete(vRunFnMap, key)
			}
		}
		vRunUsedMap = map[interface{}]bool{}

		for key := range todoCloseMap {
			if !todoUsedMap[key] {
				todoCloseMap[key]()
				delete(todoCloseMap, key)
				delete(todoFnMap, key)
			}
		}
		todoUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(deps interface{}, filter *streams.S16, todos *TodoListStream) (result dom.Element) {
		refresh = func() {

			lastresult = filteredList(depsLocal, filter, todos)

			close()
		}

		if initialized {
			switch {

			case lastfilter != filter:
			case lasttodos != todos:
			default:

				return lastresult
			}
		}
		initialized = true
		lastfilter = filter
		lasttodos = todos
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewListView is the constructor for ListViewFunc
func NewListView() (update ListViewFunc, closeAll func()) {
	var refresh func()

	var lasttodos *TodoListStream
	var lastfilterState *streams.S16
	var lastresult dom.Element
	var initialized bool
	vRunFnMap := map[interface{}]dom.VRunFunc{}
	vRunCloseMap := map[interface{}]func(){}
	vRunUsedMap := map[interface{}]bool{}

	textResetFnMap := map[interface{}]controls.TextResetFunc{}
	textResetCloseMap := map[interface{}]func(){}
	textResetUsedMap := map[interface{}]bool{}

	filterFnMap := map[interface{}]controls.FilterFunc{}
	filterCloseMap := map[interface{}]func(){}
	filterUsedMap := map[interface{}]bool{}

	filteredListFnMap := map[interface{}]FilteredListFunc{}
	filteredListCloseMap := map[interface{}]func(){}
	filteredListUsedMap := map[interface{}]bool{}

	depsLocal := &listViewDeps{
		vRun: func(key interface{}, styles dom.Styles, cells ...dom.Element) (result dom.Element) {
			vRunUsedMap[key] = true
			if vRunFnMap[key] == nil {
				vRunFnMap[key], vRunCloseMap[key] = dom.NewVRun()
			}
			return vRunFnMap[key](key, styles, cells...)
		},

		textReset: func(key interface{}, text *streams.S16, placeholder string) (result dom.Element) {
			textResetUsedMap[key] = true
			if textResetFnMap[key] == nil {
				textResetFnMap[key], textResetCloseMap[key] = controls.NewTextReset()
			}
			return textResetFnMap[key](key, text, placeholder)
		},

		filter: func(key interface{}, selected *streams.S16) (result dom.Element) {
			filterUsedMap[key] = true
			if filterFnMap[key] == nil {
				filterFnMap[key], filterCloseMap[key] = controls.NewFilter()
			}
			return filterFnMap[key](key, selected)
		},

		filteredList: func(key interface{}, filter *streams.S16, todos *TodoListStream) (result dom.Element) {
			filteredListUsedMap[key] = true
			if filteredListFnMap[key] == nil {
				filteredListFnMap[key], filteredListCloseMap[key] = NewFilteredList()
			}
			return filteredListFnMap[key](key, filter, todos)
		},
	}

	close := func() {
		for key := range vRunCloseMap {
			if !vRunUsedMap[key] {
				vRunCloseMap[key]()
				delete(vRunCloseMap, key)
				delete(vRunFnMap, key)
			}
		}
		vRunUsedMap = map[interface{}]bool{}

		for key := range textResetCloseMap {
			if !textResetUsedMap[key] {
				textResetCloseMap[key]()
				delete(textResetCloseMap, key)
				delete(textResetFnMap, key)
			}
		}
		textResetUsedMap = map[interface{}]bool{}

		for key := range filterCloseMap {
			if !filterUsedMap[key] {
				filterCloseMap[key]()
				delete(filterCloseMap, key)
				delete(filterFnMap, key)
			}
		}
		filterUsedMap = map[interface{}]bool{}

		for key := range filteredListCloseMap {
			if !filteredListUsedMap[key] {
				filteredListCloseMap[key]()
				delete(filteredListCloseMap, key)
				delete(filteredListFnMap, key)
			}
		}
		filteredListUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(deps interface{}, todos *TodoListStream) (result dom.Element) {
		refresh = func() {

			if lastfilterState != nil {
				lastfilterState = lastfilterState.Latest()
				lastfilterState.Stream.Nextf(&initialized, nil)
			}
			lastfilterState, lastresult = listView(depsLocal, todos, lastfilterState)

			if lastfilterState != nil {
				lastfilterState = lastfilterState.Latest()
				lastfilterState.Stream.Nextf(&initialized, refresh)
			}
			close()
		}

		if initialized {
			switch {

			case lasttodos != todos:
			default:

				return lastresult
			}
		}
		initialized = true
		lasttodos = todos
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewTodo is the constructor for TodoFunc
func NewTodo() (update TodoFunc, closeAll func()) {
	var refresh func()

	var lasttodoStream *TodoStream
	var lastresult dom.Element
	var initialized bool
	runFnMap := map[interface{}]dom.RunFunc{}
	runCloseMap := map[interface{}]func(){}
	runUsedMap := map[interface{}]bool{}

	checkboxEditFnMap := map[interface{}]dom.CheckboxEditFunc{}
	checkboxEditCloseMap := map[interface{}]func(){}
	checkboxEditUsedMap := map[interface{}]bool{}

	textEditFnMap := map[interface{}]dom.TextEditFunc{}
	textEditCloseMap := map[interface{}]func(){}
	textEditUsedMap := map[interface{}]bool{}

	depsLocal := &todoDeps{
		run: func(key interface{}, styles dom.Styles, cells ...dom.Element) (result dom.Element) {
			runUsedMap[key] = true
			if runFnMap[key] == nil {
				runFnMap[key], runCloseMap[key] = dom.NewRun()
			}
			return runFnMap[key](key, styles, cells...)
		},

		checkboxEdit: func(key interface{}, styles dom.Styles, checked *streams.Bool, id string) (result dom.Element) {
			checkboxEditUsedMap[key] = true
			if checkboxEditFnMap[key] == nil {
				checkboxEditFnMap[key], checkboxEditCloseMap[key] = dom.NewCheckboxEdit()
			}
			return checkboxEditFnMap[key](key, styles, checked, id)
		},

		textEdit: func(key interface{}, styles dom.Styles, text *streams.S16) (result dom.Element) {
			textEditUsedMap[key] = true
			if textEditFnMap[key] == nil {
				textEditFnMap[key], textEditCloseMap[key] = dom.NewTextEdit()
			}
			return textEditFnMap[key](key, styles, text)
		},
	}

	close := func() {
		for key := range runCloseMap {
			if !runUsedMap[key] {
				runCloseMap[key]()
				delete(runCloseMap, key)
				delete(runFnMap, key)
			}
		}
		runUsedMap = map[interface{}]bool{}

		for key := range checkboxEditCloseMap {
			if !checkboxEditUsedMap[key] {
				checkboxEditCloseMap[key]()
				delete(checkboxEditCloseMap, key)
				delete(checkboxEditFnMap, key)
			}
		}
		checkboxEditUsedMap = map[interface{}]bool{}

		for key := range textEditCloseMap {
			if !textEditUsedMap[key] {
				textEditCloseMap[key]()
				delete(textEditCloseMap, key)
				delete(textEditFnMap, key)
			}
		}
		textEditUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(deps interface{}, todoStream *TodoStream) (result dom.Element) {
		refresh = func() {

			lastresult = todo(depsLocal, todoStream)

			close()
		}

		if initialized {
			switch {

			case lasttodoStream != todoStream:
			default:

				return lastresult
			}
		}
		initialized = true
		lasttodoStream = todoStream
		refresh()
		return lastresult
	}

	return update, closeAll
}
