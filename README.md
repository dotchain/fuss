# Fuss

[![Status](https://travis-ci.com/dotchain/fuss.svg?branch=master)](https://travis-ci.com/dotchain/fuss?branch=master)
[![GoDoc](https://godoc.org/github.com/dotchain/fuss?status.svg)](https://godoc.org/github.com/dotchain/fuss)
[![codecov](https://codecov.io/gh/dotchain/fuss/branch/master/graph/badge.svg)](https://codecov.io/gh/dotchain/fuss)
[![Go Report Card](https://goreportcard.com/badge/github.com/dotchain/fuss)](https://goreportcard.com/report/github.com/dotchain/fuss)

Functional Strongly-typed Streams based reactive framework and tools

## Goals

The main goal is to build a reactive  UX framework which:

1. Composes nicely -- pure functions are the typical case
2. Uses static typing -- developers should not have to use casts or interfaces
3. Supports multiple side-by-side versions of the framework in the same app
4. Uses **Streams** for managing change.

## Examples

A sample TODO MVC app
[demo](https://dotchain.github.io/fuss/todo/html/index.html) is the
running version of the code in the
[todo](https://github.com/dotchain/fuss/tree/master/todo) folder (with
the actual hosting of it in
[todo/html](https://github.com/dotchain/fuss/tree/master/todo)

The following walk-through illustrates how this is put together

### A single task

A single task represents one item in a list of TODOs.  The
corresponding UX control renders the `Done` flag using a checkbox and
the `Description` using a text edit control.  This is an example of a
control which accepts input that can also be be modified.  This is
mananged through a **Stream** interface which is like a linked list
with notifications support.

```golang

// Task represents an item in the TODO list.
type Task struct {
	ID          string
	Done        bool
	Description string
}


// TaskEdit is a pure functional control which takes a TaskStream
// and updates it whenever the checkbox or text edit control changes
func taskEdit(c *taskEditCtx, styles dom.Styles, task *TaskStream) dom.Element {
	return c.dom.Element(
		"root",
		dom.Props{Tag: "div", Styles: styles},
		c.dom.CheckboxEdit("cb", dom.Styles{}, task.DoneSubstream(c.Cache)),
		c.dom.TextEdit("textedit", dom.Styles{}, task.DescriptionSubstream(c.Cache)),
	)
}
```

The code for `Task` stream is auto-generated which also generates the
interesting methods of `DoneSubstream` and `DescriptionSubstream`. A
substream holds a sequence of changes to a part of the data taking
care to synchronize with the super-stream.

In the code snippet above, the core component **taskEdit** is  a pure
function which takes a context parameter.  The context struct type is
unique to this function and is automatically generated by FOSS based
on which sub-compoents `taskEdit` uses.  In this example,
`dom.CheckboxEdit` and `dom.TextEdit` are used and so, the generated
code for `taskEditCtx` will reflect that.

The core of the `taskEdit` function is the call to create a
`dom.Element`.  Such **sub-components** always take a **key** as the
first argument. This is basically a way to reuse a sub-component from
previous run.

### A list of tasks

Using the `taskEdit` componennt, we can build a list of tasks
component that also filters on whether to show completed and
incomplete tasks.

```golang

// Tasks represents a collection of tasks
type Tasks []Task

// TasksView is a control that renders tasks using TaskEdit.
//
// Individual tasks can be modified underneath resulting in changes to
// the TaskStream.
func tasksView(c *tasksViewCtx, styles dom.Styles, showDone *streams.BoolStream, showNotDone *streams.BoolStream, tasks *TasksStream) dom.Element {
	return c.dom.Element(
		"root",
		dom.Props{Tag: "div", Styles: styles},
		renderTasks(tasks.Value, func(index int, t Task) dom.Element {
			// filter out tasks based on showDone and showNotDone
			if t.Done && !showDone.Value || !t.Done && !showNotDone.Value {
				return nil
			}

			// get the individual stream for this task
                        taskStream := tasks.Substream(c.Cache, index)

			// do the actual rendering using t.ID as "key"
			return c.TaskEdit(t.ID, dom.Styles{}, taskStream)
		})...,
	)
}

func renderTasks(t Tasks, fn func(int, Task) dom.Element) []dom.Element {
	result := make([]dom.Element, len(t))
	for kk, elt := range t {
		result[kk] = fn(kk, elt)
	}
	return result
}
```

In this example above, the `tasksView` component uses the `TaskEdit`
as a sub-component by calling `c.TaskEdit`. In this call, the first
parameter has been replaced by a `key` using the task ID.  Note also
that a stream is automatically created for `Tasks` which supports the
`Substream` method for each child entry (and which also synchronizes
with each other).

### Stateful example

Sometimes, there is no avoiding state. In the example above, imagine a
wrapper container which exposes the `Done` and `NotDone` filters via
checkboxes local to itself.  The consumers of this **container** are
neither interested-in nor awaare-of these filter states.

The state here would be the two streams asssociated with the
corresponding checkboxes. These are modeled in FUSS as dual
input/output params with the **State** suffix in the name:


```golang

// Container renders a tasks list with two filters
func container(c *appCtx, styles dom.Styles, tasks *TasksStream, doneState *streams.BoolStream, notDoneState *streams.BoolStream) (*streams.BoolStream, *streams.BoolStream, dom.Element) {
	// initialize the state the first time around
	if doneState == nil {
		doneState = streams.NewBoolStream(true)
	}
	if notDoneState == nil {
		notDoneState = streams.NewBoolStream(true)
	}

	// return the state and the actual return value
	return doneState, notDoneState, c.dom.Element(
		"root",
		dom.Props{Tag: "div", Styles: styles},
		c.dom.Checkbox("done", dom.Styles{}, doneState),
		c.dom.Checkbox("notDone", dom.Styles{}, notDoneState),
		c.TasksView("tasks", dom.Styles{}, doneState, notDoneState, tasks),
	)
}
```

The `doneState` and `notDoneState` are both passed as args and
expected as result as far as the component itself is concerned. To
callers, the state args are not present in the input or
output. Underneath, the framework silently injects these additionally
taking care to refresh the component when the state is updated.

The example above would have been a bit more elegant if one used a
single state stream but that was not done for the sake of simplicity.

## How does all this work?

Every component function has two associated types that are
automatically generated: the context type  (the first parameter to the
function) as well as a *struct* type which is the primary interface
for consumers of the component.

The context type caches the input and output params from the last call
as well as all the sub-components used. When a component uses the
context to create a sub-component, the corresponding cache of that
subcomponent is used to reuse a prior value if no parameters to it
have changed.

### The context type

The context type roughly looks like this:

```golang

type componentContext {
	// for each subPkg.subComponent used by the component
	subPkg struct {
		subComponentStruct
	}

        // memoized tracks all previous args and results
        memoized struct {
        	arg1 argType1 ....
        }
}
```

In the previous examples, when a component decides to create a
checkbox via `c.dom.CheckboxEdit(...)`, the associated context type
would have a field like so:

```golang

type componentContext {
	dom struct {
        	dom.CheckboxEditStruct
        }
        ...
}
```

The  `dom.CheckboxEditStruct` implements a `CheckboxEdit(...)`
function and so the call to `c.dom.CheckboxEdit(...)`
works. Underneath the covers, every `Struct` type maintains a cache of
its contexts. This cache is used to lookup an individual context and
if found, previous values are reused as necessary.
