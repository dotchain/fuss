# Fuss

Functional Strongly-typed Streams based reactive framework and tools

## Goals

The main goal is to build a reactive  UX framework which:

1. Composes nicely -- pure functions are the typical case
2. Uses static typing -- developers should not have to use casts or interfaces
3. Supports multiple side-by-side versions of the framework in the same app
4. Uses **Streams** for managing change.

## Examples

A sample TODO MVC app written in this style can be seen in the
[todo](https://github.com/dotchain/fuss/tree/master/todo) folder.

The following walk-through illustrates how this is put together

### A single task

A single task represents one item in a list of TODOs.  The
corresponding UX control renders the `Done` flag using a checkbox and
the `Description` using a text edit control.  This is an example of a
control which accepts input that can also be be modified.  This is
mananged through a **Stream** interface which is like a linked list
with notifications support.

```golang

// Task represents an item in the TODO list.
type Task struct {
	ID          string
	Done        bool
	Description string
}


// TaskEdit is a pure functional control which takes a TaskStream
// and updates it whenever the checkbox or text edit control changes
func taskEdit(c *taskEditCtx, styles dom.Styles, task *TaskStream) dom.Element {
	return c.dom.Element(
		"root",
		dom.Props{Tag: "div", Styles: styles},
		c.dom.CheckboxEdit("cb", dom.Styles{}, task.DoneSubstream(c.Cache)),
		c.dom.TextEdit("textedit", dom.Styles{}, task.DescriptionSubstream(c.Cache)),
	)
}
```

The code for `Task` stream is auto-generated which also generates the
interesting methods of `DoneSubstream` and `DescriptionSubstream`. A
substream holds a sequence of changes to a part of the data taking
care to synchronize with the super-stream.

In the code snippet above, the core component **taskEdit** is  a pure
function which takes a context parameter.  The context struct type is
unique to this function and is automatically generated by FOSS based
on which sub-compoents `taskEdit` uses.  In this example,
`dom.CheckboxEdit` and `dom.TextEdit` are used and so, the generated
code for `taskEditCtx` will reflect that.

The core of the `taskEdit` function is the call to create a
`dom.Element`.  Such **sub-components** always take a **key** as the
first argument. This is basically a way to reuse a sub-component from
previous run.

### A list of tasks

Using the `taskEdit` componennt, we can build a list of tasks
component that also filters on whether to show completed and
incomplete tasks.

```golang

// Tasks represents a collection of tasks
type Tasks []Task

// TasksView is a control that renders tasks using TaskEdit.
//
// Individual tasks can be modified underneath resulting in changes to
// the TaskStream.
func tasksView(c *tasksViewCtx, styles dom.Styles, showDone *streams.BoolStream, showNotDone *streams.BoolStream, tasks *TasksStream) dom.Element {
	return c.dom.Element(
		"root",
		dom.Props{Tag: "div", Styles: styles},
		renderTasks(tasks.Value, func(index int, t Task) dom.Element {
			// filter out tasks based on showDone and showNotDone
			if t.Done && !showDone.Value || !t.Done && !showNotDone.Value {
				return nil
			}

			// get the individual stream for this task
                        taskStream := tasks.Substream(c.Cache, index)

			// do the actual rendering using t.ID as "key"
			return c.TaskEdit(t.ID, dom.Styles{}, taskStream)
		})...,
	)
}

func renderTasks(t Tasks, fn func(int, Task) dom.Element) []dom.Element {
	result := make([]dom.Element, len(t))
	for kk, elt := range t {
		result[kk] = fn(kk, elt)
	}
	return result
}
```

In this example above, the `tasksView` component uses the `TaskEdit`
as a sub-component by calling `c.TaskEdit`. In this call, the first
parameter has been replaced by a `key` using the task ID.  Note also
that a stream is automatically created for `Tasks` which supports the
`Substream` method for each child entry (and which also synchronizes
with each other).

### Stateful example

Sometimes, there is no avoiding state. In the example above, imagine a
wrapper container which exposes the `Done` and `NotDone` filters via
checkboxes local to itself.  The consumers of this **container** are
neither interested-in nor awaare-of these filter states.

The state here would be the two streams asssociated with the
corresponding checkboxes. These are modeled in FUSS as dual
input/output params with the **State** suffix in the name:


```golang

// Container renders a tasks list with two filters
func container(c *appCtx, styles dom.Styles, tasks *TasksStream, doneState *streams.BoolStream, notDoneState *streams.BoolStream) (*streams.BoolStream, *streams.BoolStream, dom.Element) {
	// initialize the state the first time around
	if doneState == nil {
		doneState = streams.NewBoolStream(true)
	}
	if notDoneState == nil {
		notDoneState = streams.NewBoolStream(true)
	}

	// return the state and the actual return value
	return doneState, notDoneState, c.dom.Element(
		"root",
		dom.Props{Tag: "div", Styles: styles},
		c.dom.Checkbox("done", dom.Styles{}, doneState),
		c.dom.Checkbox("notDone", dom.Styles{}, notDoneState),
		c.TasksView("tasks", dom.Styles{}, doneState, notDoneState, tasks),
	)
}
```

The `doneState` and `notDoneState` are both passed as args and
expected as result as far as the component itself is concerned. To
callers, the state args are not present in the input or
output. Underneath, the framework silently injects these additionally
taking care to refresh the component when the state is updated.

The example above would have been a bit more elegant if one used a
single state stream but that was not done for the sake of simplicity.

## How does all this work?

Most of the  magic here is by code generation. 

### The core interface

For every pure function (which can be private), there is a struct defined with the following shape:

```golang

type ComponentStruct {....}
func (c *ComponentStruct) Begin() {...}
func (c *ComponentStruct) End() {...}
func (c *ComponentStruct) MainMethod(key interface{}, args) results {
     // args are same as for pure function except:  no context or state
     // results are same as for pure function except: no state 
     
     // function checks if key exists in cache.
     // if not, the pure function is called with a new context
     // else pure function is called only if args  differ, using cached results instead
}
```

This struct is the core contract between components: the `Begin` is
used to indicate a new round with the `End` concluding the current
round.  This allows tracking if the parent  is no longer using  this
sub-componennt and dropping it out of the cache when that happens. 

For each pure function, the corresponding struct is automatically
created  where the cache simply maintains the context. The context
itself contains all the sub-components used by a particular
component.

More explanation to follow.