# Fuss
Functional Strongly-typed Streams based reactive framework and tools

## Goals

The main goal is to build a reactive  UX framework which:

1. Composes nicely. Pure functions are the typical case.
2. Uses strong static typing. Type-casts and conversions are not *idiomatic*.
3. Supports multiple side-by-side version by having a thin surface area
3. Uses *Streams* for managing change.

## Examples

Examples on how to write a component are probably easier, so they are considered first here.  A later section also includes the inner workings.

### A single task

A simple component which renders a checkbox + text control would look like this

```golang

// Task represents an item in the TODO list.
type Task struct {
	ID          string
	Done        bool
	Description string
}


// taskEdit is a pure functional control which takes a TaskStream
// and updates it whenever the checkbox or text edit control changes
func taskEdit(c *taskEditCtx, styles core.Styles, task *TaskStream) controls.Element {
	return c.controls.Element(
		"root",
		controls.Props{Tag: "div", Styles: styles},
		c.controls.Checkbox("cb", core.Styles{}, task.DoneSubstream(c.Cache)),
		c.controls.TextEdit("textedit", core.Styles{}, task.DescriptionSubstream(c.Cache)),
	)
}
```

In this example, the core component **taskEdit** is  a pure function which takes a context parameter. The context struct type is unique to this function and automatically generated by FOSS based on which sub-compoents it uses.  In this example, `controls.Checkbox` and `controls.TextEdit` are used and so, the generated code for `taskEditCtx` will reflect that.

The `TaskStream` type is also automatically generated from `Task` which, because it has an annotated `Done` field, the corresponding `DoneSubstream` is also automatically generated.   This is useful because any changes to substreams are propagated to the parent streams automatically.

The core of the `taskEdit` function is the call to create a `controls.Element`.  Such **sub-components** always take a **key** first argument (instead of the corresponding private context) and the generated code automatically re-uses an older value if one exists. 

When such a component is created, a corresponding struct `TaskEdit` is created which can be used by a consumer -- such as in displaying a list of tasks:

### A list of tasks

```golang

// Tasks represents a collection of tasks
type Tasks []Task

// tasksView is a control that renders tasks using TaskEdit.
//
// Individual tasks can be modified underneath. The current list of
// tasks is available via Tasks field which supports On/Off to receive
// notifications.
func tasksView(c *tasksViewCtx, styles core.Styles, showDone *streams.BoolStream, showNotDone *streams.BoolStream, tasks *TasksStream) core.Element {
	return c.controls.Element(
		"root",
		controls.Props{Tag: "div", Styles: styles},
		renderTasks(tasks.Value, func(index int, t Task) controls.Element {
			if t.Done && !showDone.Value || !t.Done && !showNotDone.Value {
				return nil
			}

			return c.TaskEdit(t.ID, core.Styles{}, tasks.Substream(c.Cache, index))
		})...,
	)
}

func renderTasks(t Tasks, fn func(int, Task) core.Element) []controls.Element {
	result := make([]controls.Element, len(t))
	for kk, elt := range t {
		result[kk] = fn(kk, elt)
	}
	return result
}
```

In this example above, the `tasksView` component uses the `TaskEdit` as a sub-component by calling `c.TaskEdit`. Note that the first parameter has been replaced by a `key` of any type.  Note also that a stream is automatically created for `Tasks` (with the ability to get a two-way sub-stream for a particular entry).  The list example also includes filters for whether to show `Done` and `!Done` tasks though the filter is just a param and not rendered itself

### Stateful example

Sometimes, there is no avoiding state. In the example above, imagine a wrapper container which exposes the `Done` and `NotDone` filters via checkboxes local to itself.  The consumers of this **container** are neither interested-in nor awaare-of these filter statess.  So, the corresponding streams are modeled as **input** and **output** parameters:

```golang
func container(c *appCtx, styles core.Styles, tasks *TasksStream, doneState *streams.BoolStream, notDoneState *streams.BoolStream) (controls.Element, *streams.BoolStream, *streams.BoolStream) {
	if doneState == nil {
		doneState = streams.NewBoolStream(true)
	}
	if notDoneState == nil {
		notDoneState = streams.NewBoolStream(true)
	}

	return c.controls.Element(
		"root",
		controls.Props{Tag: "div", Styles: styles},
		c.controls.Checkbox("done", core.Styles{}, doneState),
		c.controls.Checkbox("notDone", core.Styles{}, notDoneState),
		c.TasksView("tasks", core.Styles{}, doneState, notDoneState, tasks),
	), doneState, notDoneState
}
```

The `doneState` and `notDoneState` are both passed as args and expected as result as far as the component itself is concernned..  The pure function can check if it was not specified and initialize them as needed, secure in the knowledge that the next call will return these as parameters (as well as automatically refresh itself when the state changes making it reactive)

Consumers of `container` will not see `doneState` and `notDoneState` in either the parameter or the results list. It is automtically injected by the framework.

## How does this work?

Most of the  magic here is by code generation. 

### The core interface

For every pure function (which can be private), there is a struct defined with the following shape:

```golang

type ComponentStruct {....}
func (c *ComponentStruct) Begin() {...}
func (c *ComponentStruct) End() {...}
func (c *ComponentStruct) MainMethod(key interface{}, args) results {
     // args are same as for pure function except:  no context or state
     // results are same as for pure function except: no state 
     
     // function checks if key exists in cache.
     // if not, the pure function is called with a new context
     // else pure function is called only if args  differ, using cached results instead
}
```

This struct is the core contract between components: the `Begin` is used to indicate a new round with the `End` concluding the current round.  This allows tracking if the parent  is no longer using  this sub-componennt and dropping it out of the cache when that happens.

For each pure function, the corresponding struct is automatically created  where the cache simply maintains the context. The context itself contains all the sub-components used by a particular component.
