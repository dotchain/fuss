// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.
//
// Code generated by github.com/dotchain/fuss/dom/codegen.go. DO NOT EDIT.

package dom

import (
	streams "github.com/dotchain/dot/streams"
)

// NewA is the constructor for AFunc
func NewA() (update AFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lasthref string
	var lastchildren []Element
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, href string, children ...Element) (result Element) {
		refresh = func() {

			lastresult = a(cLocal, styles, href, children...)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			case lasthref != href:
			default:

				if len(lastchildren) != len(children) {
					break
				}
				diff := false
				for kk := 0; !diff && kk < len(children); kk++ {

					diff = lastchildren[kk] != children[kk]

				}
				if diff {
					break
				}

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lasthref = href
		lastchildren = children
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewButton is the constructor for ButtonFunc
func NewButton() (update ButtonFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lastonClick *EventHandler
	var lastchildren []Element
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, onClick *EventHandler, children ...Element) (result Element) {
		refresh = func() {

			lastresult = button(cLocal, styles, onClick, children...)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			case lastonClick != onClick:
			default:

				if len(lastchildren) != len(children) {
					break
				}
				diff := false
				for kk := 0; !diff && kk < len(children); kk++ {

					diff = lastchildren[kk] != children[kk]

				}
				if diff {
					break
				}

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lastonClick = onClick
		lastchildren = children
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewCheckboxEdit is the constructor for CheckboxEditFunc
func NewCheckboxEdit() (update CheckboxEditFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lastchecked *streams.Bool
	var lastid string
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, checked *streams.Bool, id string) (result Element) {
		refresh = func() {

			lastresult = checkboxEdit(cLocal, styles, checked, id)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			case lastchecked != checked:
			case lastid != id:
			default:

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lastchecked = checked
		lastid = id
		refresh()
		return lastresult
	}

	return update, closeAll
}

// newelt is the constructor for eltFunc
func newelt() (update eltFunc, closeAll func()) {
	var refresh func()

	var lastlastState *nodeStream
	var lastprops Props
	var lastchildren []Element
	var lastresult Element
	var initialized bool

	cLocal := &noDeps{}

	close := func() {}

	closeAll = func() {
		close()
		lastlastState.Close()

		if lastlastState != nil {
			lastlastState.Stream.Nextf(&initialized, nil)
		}
	}

	update = func(c interface{}, props Props, children ...Element) (result Element) {
		refresh = func() {

			if lastlastState != nil {
				lastlastState = lastlastState.Latest()
				lastlastState.Stream.Nextf(&initialized, nil)
			}
			lastlastState, lastresult = elt(cLocal, lastlastState, props, children...)

			if lastlastState != nil {
				lastlastState = lastlastState.Latest()
				lastlastState.Stream.Nextf(&initialized, refresh)
			}
			close()
		}

		if initialized {
			switch {

			case lastprops != props:
			default:

				if len(lastchildren) != len(children) {
					break
				}
				diff := false
				for kk := 0; !diff && kk < len(children); kk++ {

					diff = lastchildren[kk] != children[kk]

				}
				if diff {
					break
				}

				return lastresult
			}
		}
		initialized = true
		lastprops = props
		lastchildren = children
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewFixed is the constructor for FixedFunc
func NewFixed() (update FixedFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lastcells []Element
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, cells ...Element) (result Element) {
		refresh = func() {

			lastresult = fixed(cLocal, styles, cells...)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			default:

				if len(lastcells) != len(cells) {
					break
				}
				diff := false
				for kk := 0; !diff && kk < len(cells); kk++ {

					diff = lastcells[kk] != cells[kk]

				}
				if diff {
					break
				}

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lastcells = cells
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewFocusable is the constructor for FocusableFunc
func NewFocusable() (update FocusableFunc, closeAll func()) {
	var refresh func()

	var lasteh *EventHandler
	var lastchildren []Element
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, eh *EventHandler, children ...Element) (result Element) {
		refresh = func() {

			lastresult = focusable(cLocal, eh, children...)

			close()
		}

		if initialized {
			switch {

			case lasteh != eh:
			default:

				if len(lastchildren) != len(children) {
					break
				}
				diff := false
				for kk := 0; !diff && kk < len(children); kk++ {

					diff = lastchildren[kk] != children[kk]

				}
				if diff {
					break
				}

				return lastresult
			}
		}
		initialized = true
		lasteh = eh
		lastchildren = children
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewImg is the constructor for ImgFunc
func NewImg() (update ImgFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lastsrc string
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, src string) (result Element) {
		refresh = func() {

			lastresult = img(cLocal, styles, src)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			case lastsrc != src:
			default:

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lastsrc = src
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewLabelView is the constructor for LabelViewFunc
func NewLabelView() (update LabelViewFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lasttext string
	var lastinputID string
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, text string, inputID string) (result Element) {
		refresh = func() {

			lastresult = labelView(cLocal, styles, text, inputID)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			case lasttext != text:
			case lastinputID != inputID:
			default:

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lasttext = text
		lastinputID = inputID
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewLiveTextEdit is the constructor for LiveTextEditFunc
func NewLiveTextEdit() (update LiveTextEditFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lasttext *streams.S16
	var lastplaceholder string
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, text *streams.S16, placeholder string) (result Element) {
		refresh = func() {

			lastresult = liveTextEdit(cLocal, styles, text, placeholder)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			case lasttext != text:
			case lastplaceholder != placeholder:
			default:

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lasttext = text
		lastplaceholder = placeholder
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewRun is the constructor for RunFunc
func NewRun() (update RunFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lastcells []Element
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, cells ...Element) (result Element) {
		refresh = func() {

			lastresult = run(cLocal, styles, cells...)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			default:

				if len(lastcells) != len(cells) {
					break
				}
				diff := false
				for kk := 0; !diff && kk < len(cells); kk++ {

					diff = lastcells[kk] != cells[kk]

				}
				if diff {
					break
				}

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lastcells = cells
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewStretch is the constructor for StretchFunc
func NewStretch() (update StretchFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lastcells []Element
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, cells ...Element) (result Element) {
		refresh = func() {

			lastresult = stretch(cLocal, styles, cells...)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			default:

				if len(lastcells) != len(cells) {
					break
				}
				diff := false
				for kk := 0; !diff && kk < len(cells); kk++ {

					diff = lastcells[kk] != cells[kk]

				}
				if diff {
					break
				}

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lastcells = cells
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewTextEdit is the constructor for TextEditFunc
func NewTextEdit() (update TextEditFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lasttext *streams.S16
	var lastresult Element
	var initialized bool
	textEditOFnMap := map[interface{}]TextEditOFunc{}
	textEditOCloseMap := map[interface{}]func(){}
	textEditOUsedMap := map[interface{}]bool{}

	cLocal := &textEditDep{
		textEditO: func(key interface{}, opt TextEditOptions) (result Element) {
			textEditOUsedMap[key] = true
			if textEditOFnMap[key] == nil {
				textEditOFnMap[key], textEditOCloseMap[key] = NewTextEditO()
			}
			return textEditOFnMap[key](key, opt)
		},
	}

	close := func() {
		for key := range textEditOCloseMap {
			if !textEditOUsedMap[key] {
				textEditOCloseMap[key]()
				delete(textEditOCloseMap, key)
				delete(textEditOFnMap, key)
			}
		}
		textEditOUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, text *streams.S16) (result Element) {
		refresh = func() {

			lastresult = textEdit(cLocal, styles, text)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			case lasttext != text:
			default:

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lasttext = text
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewTextEditO is the constructor for TextEditOFunc
func NewTextEditO() (update TextEditOFunc, closeAll func()) {
	var refresh func()

	var lastopt TextEditOptions
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, opt TextEditOptions) (result Element) {
		refresh = func() {

			lastresult = textEditO(cLocal, opt)

			close()
		}

		if initialized {
			switch {

			case lastopt != opt:
			default:

				return lastresult
			}
		}
		initialized = true
		lastopt = opt
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewTextInput is the constructor for TextInputFunc
func NewTextInput() (update TextInputFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lasteh *EventHandler
	var lastid string
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, eh *EventHandler, id string) (result Element) {
		refresh = func() {

			lastresult = textInput(cLocal, styles, eh, id)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			case lasteh != eh:
			case lastid != id:
			default:

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lasteh = eh
		lastid = id
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewTextView is the constructor for TextViewFunc
func NewTextView() (update TextViewFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lasttext string
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, text string) (result Element) {
		refresh = func() {

			lastresult = textView(cLocal, styles, text)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			case lasttext != text:
			default:

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lasttext = text
		refresh()
		return lastresult
	}

	return update, closeAll
}

// NewVRun is the constructor for VRunFunc
func NewVRun() (update VRunFunc, closeAll func()) {
	var refresh func()

	var laststyles Styles
	var lastcells []Element
	var lastresult Element
	var initialized bool
	eltFnMap := map[interface{}]eltFunc{}
	eltCloseMap := map[interface{}]func(){}
	eltUsedMap := map[interface{}]bool{}

	cLocal := &eltDep{
		elt: func(key interface{}, props Props, children ...Element) (result Element) {
			eltUsedMap[key] = true
			if eltFnMap[key] == nil {
				eltFnMap[key], eltCloseMap[key] = newelt()
			}
			return eltFnMap[key](key, props, children...)
		},
	}

	close := func() {
		for key := range eltCloseMap {
			if !eltUsedMap[key] {
				eltCloseMap[key]()
				delete(eltCloseMap, key)
				delete(eltFnMap, key)
			}
		}
		eltUsedMap = map[interface{}]bool{}
	}

	closeAll = func() {
		close()

	}

	update = func(c interface{}, styles Styles, cells ...Element) (result Element) {
		refresh = func() {

			lastresult = vRun(cLocal, styles, cells...)

			close()
		}

		if initialized {
			switch {

			case laststyles != styles:
			default:

				if len(lastcells) != len(cells) {
					break
				}
				diff := false
				for kk := 0; !diff && kk < len(cells); kk++ {

					diff = lastcells[kk] != cells[kk]

				}
				if diff {
					break
				}

				return lastresult
			}
		}
		initialized = true
		laststyles = styles
		lastcells = cells
		refresh()
		return lastresult
	}

	return update, closeAll
}
